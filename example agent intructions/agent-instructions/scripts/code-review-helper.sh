#!/bin/bash

# Code Review Helper Script
# This script abstracts all git commands needed for code review to avoid individual permission requests
# Usage: ./code-review-helper.sh [branch-name] [review-type]
#
# Arguments:
#   branch-name: Optional. If provided, reviews that specific branch. If not provided, reviews current branch
#               Supports various formats: issue/RVRY-123, feature/ABC-456, spr/t/JFP-5248, ABC-123
#   review-type: Optional. Either "local" (default) or "remote"
#
# Examples:
#   ./code-review-helper.sh                          # Review current branch
#   ./code-review-helper.sh issue/RVRY-123           # Review specific local branch
#   ./code-review-helper.sh feature/ABC-123 remote   # Review remote branch
#   ./code-review-helper.sh ABC-123                  # Review branch by ticket ID

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Safety thresholds (can be overridden via environment variables)
MAX_FILES_THRESHOLD=${MAX_FILES_THRESHOLD:-100}
MAX_INSERTIONS_THRESHOLD=${MAX_INSERTIONS_THRESHOLD:-5000}
MAX_DELETIONS_THRESHOLD=${MAX_DELETIONS_THRESHOLD:-5000}

# Default values
BRANCH_NAME=""
REVIEW_TYPE="local"
REPO_ROOT=""
CURRENT_DIR=""
CONTEXT_DIR=""
REMOTE_ALREADY_FETCHED=false
REVIEWING_CURRENT_BRANCH=false  # True when no branch arg provided (review current with uncommitted changes)

# Parse arguments
if [ $# -ge 1 ]; then
    BRANCH_NAME="$1"
fi

if [ $# -ge 2 ]; then
    REVIEW_TYPE="$2"
fi

# Function to print colored output
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Function to validate diff statistics and detect anomalies
validate_diff_stats() {
    local files_changed="$1"
    local insertions="$2"
    local deletions="$3"
    local branch_name="$4"
    local commit_range="$5"

    local threshold_exceeded=false
    local reasons=()

    # Check for excessive file changes
    if [ "$files_changed" -gt "$MAX_FILES_THRESHOLD" ]; then
        threshold_exceeded=true
        reasons+=("Files changed: $files_changed (threshold: $MAX_FILES_THRESHOLD)")
    fi

    # Check for excessive insertions
    if [ "$insertions" -gt "$MAX_INSERTIONS_THRESHOLD" ]; then
        threshold_exceeded=true
        reasons+=("Insertions: +$insertions lines (threshold: $MAX_INSERTIONS_THRESHOLD)")
    fi

    # Check for excessive deletions
    if [ "$deletions" -gt "$MAX_DELETIONS_THRESHOLD" ]; then
        threshold_exceeded=true
        reasons+=("Deletions: -$deletions lines (threshold: $MAX_DELETIONS_THRESHOLD)")
    fi

    # If any threshold exceeded, show diagnostics and exit
    if [ "$threshold_exceeded" = true ]; then
        echo ""
        print_error "üö® SAFETY NET TRIGGERED üö®"
        echo ""

        # Check for merge commits first to determine the message
        local merge_commits=$(git log --oneline --merges "$commit_range" 2>/dev/null | head -5)

        if [ -n "$merge_commits" ]; then
            echo "Excessive changes detected. This branch likely contains merged changes from master."
        else
            echo "Excessive changes detected. This may be a large refactor, data change, or autogenerated code."
        fi

        echo ""
        echo "üìä Statistics:"
        echo "  ‚Ä¢ Files changed: $files_changed (threshold: $MAX_FILES_THRESHOLD)"
        echo "  ‚Ä¢ Insertions: +$insertions lines (threshold: $MAX_INSERTIONS_THRESHOLD)"
        echo "  ‚Ä¢ Deletions: -$deletions lines (threshold: $MAX_DELETIONS_THRESHOLD)"
        echo ""
        echo "‚ùå Threshold(s) exceeded:"
        for reason in "${reasons[@]}"; do
            echo "  ‚Ä¢ $reason"
        done
        echo ""
        echo "üîç Diagnostics:"
        echo "  ‚Ä¢ Branch: $branch_name"
        echo "  ‚Ä¢ Commit range: $commit_range"
        echo ""

        # Show merge commits if detected
        if [ -n "$merge_commits" ]; then
            echo "‚ö†Ô∏è  Merge commits detected (showing first 5):"
            echo "$merge_commits" | while read -r line; do
                echo "     $line"
            done
            echo ""
            echo "üí° This branch has merged master, bringing in unrelated changes."
        else
            echo "üí° No merge commits detected. This may be a legitimate large change."
        fi

        echo ""
        echo "‚öôÔ∏è  To override this safety check, set environment variables before running:"
        echo "    MAX_FILES_THRESHOLD=500 MAX_INSERTIONS_THRESHOLD=10000 ./code-review-helper.sh $branch_name"
        echo ""

        exit 1
    fi
}

# Function to get repository information
get_repo_info() {
    print_status "Getting repository information..."

    # Get repository root
    REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || echo "")
    if [ -z "$REPO_ROOT" ]; then
        print_error "Not in a git repository"
        exit 1
    fi

    # Get current directory
    CURRENT_DIR=$(pwd)

    print_success "Repository root: $REPO_ROOT"
    print_success "Current directory: $CURRENT_DIR"
}

# Function to check if we're in the jira directory
validate_jira_context() {
    if [[ ! "$REPO_ROOT" =~ /jira$ ]] && [[ ! "$CURRENT_DIR" =~ /jira/ ]]; then
        print_warning "This script is designed for Jira frontend development"
        print_warning "Repository root: $REPO_ROOT"
        print_warning "Current directory: $CURRENT_DIR"
        print_warning "Continuing anyway, but results may not be optimal"
    fi
}

# Function to fetch remote branch if needed
fetch_remote_branch() {
    # Skip if already fetched during validation
    if [ "$REMOTE_ALREADY_FETCHED" = true ]; then
        print_status "Remote branch already fetched, skipping redundant fetch"
        return 0
    fi

    if [ -n "$BRANCH_NAME" ] && [ "$REVIEW_TYPE" = "remote" ]; then
        print_status "Fetching remote branch: $BRANCH_NAME"
        if ! git fetch origin "$BRANCH_NAME" 2>/dev/null; then
            print_error "Failed to fetch branch '$BRANCH_NAME' from remote"
            print_error "Branch may not exist or you may not have access"
            exit 1
        fi
        print_success "Successfully fetched remote branch: $BRANCH_NAME"
    fi
}

# Function to validate branch existence
validate_branch_exists() {
    local branch_name="$1"
    local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

    # If no branch specified, we'll use current branch - that's always valid
    if [ -z "$branch_name" ]; then
        return 0
    fi

    # Check if this is the current branch
    if [ "$branch_name" = "$current_branch" ]; then
        return 0
    fi

    # For remote review, check remote branch
    if [ "$REVIEW_TYPE" = "remote" ]; then
        print_status "Validating remote branch: $branch_name"

        # Check if origin/branch exists locally (already fetched)
        if git rev-parse --verify "origin/$branch_name" >/dev/null 2>&1; then
            return 0
        fi

        # Try to fetch it
        print_status "Fetching remote branch: $branch_name"
        if git fetch origin "$branch_name" >/dev/null 2>&1; then
            return 0
        fi

        # Branch doesn't exist remotely
        print_error "Branch '$branch_name' does not exist on remote 'origin'"
        echo ""
        echo "üìç Current branch: $current_branch"
        echo ""
        echo "Possible issues:"
        echo "  ‚Ä¢ Branch name is incorrect"
        echo "  ‚Ä¢ Branch hasn't been pushed to remote yet"
        echo "  ‚Ä¢ You don't have access to this branch"
        echo ""
        echo "üí° Suggestions:"
        echo "  1. Review current branch instead: ./$(basename "$0")"
        echo "  2. Check branch name spelling"
        echo "  3. List remote branches: git branch -r | grep '$branch_name'"
        echo ""
        exit 1
    fi

    # For local review, check local branch
    print_status "Validating local branch: $branch_name"

    # Check if branch exists locally
    if git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
        return 0
    fi

    # Try to find similar branches locally
    local similar_branches=$(git branch --list "*$branch_name*" | sed 's/^[* ]*//' | head -n 5)

    if [ -n "$similar_branches" ]; then
        print_error "Branch '$branch_name' not found, but found similar branches:"
        echo ""
        echo "$similar_branches" | while read -r branch; do
            echo "  ‚Ä¢ $branch"
        done
        echo ""
        echo "üìç Current branch: $current_branch"
        echo ""
        echo "üí° Did you mean one of these?"
        echo "  Or review current branch: ./$(basename "$0")"
        echo ""
        exit 1
    fi

    # No local branches found, search remote without full fetch
    print_status "Branch not found locally, searching remote branches..."

    # Use git ls-remote to search for branches without fetching everything
    # This is much more efficient than git fetch origin
    local remote_branches=$(git ls-remote --heads origin "*$branch_name*" 2>/dev/null | \
        sed 's|.*refs/heads/||' | head -n 10)

    if [ -n "$remote_branches" ]; then
        local branch_count=$(echo "$remote_branches" | wc -l | tr -d ' ')

        if [ "$branch_count" -eq 1 ]; then
            # Exactly one match found - auto-switch to remote review
            local found_branch=$(echo "$remote_branches" | head -n 1)
            print_success "Found remote branch: $found_branch"
            print_status "Automatically switching to remote review mode..."

            # Fetch only this specific branch
            if git fetch origin "$found_branch" >/dev/null 2>&1; then
                print_success "Successfully fetched remote branch"
                # Update global variables for remote review
                REVIEW_TYPE="remote"
                BRANCH_NAME="$found_branch"
                # Set flag to skip redundant fetch later
                REMOTE_ALREADY_FETCHED=true
                return 0
            else
                print_error "Failed to fetch remote branch"
                exit 1
            fi
        else
            # Multiple matches found
            print_warning "Found $branch_count matching remote branches:"
            echo ""
            echo "$remote_branches" | while read -r branch; do
                echo "  ‚Ä¢ $branch"
            done
            echo ""
            echo "üìç Current branch: $current_branch"
            echo ""
            echo "üí° Please specify the full branch name:"
            echo "  Example: ./$(basename "$0") <full-branch-name> remote"
            echo ""
            exit 1
        fi
    fi

    # No branches found locally or remotely
    print_error "Branch '$branch_name' does not exist locally or remotely"
    echo ""
    echo "üìç Current branch: $current_branch"
    echo ""
    echo "Possible issues:"
    echo "  ‚Ä¢ Branch name is incorrect"
    echo "  ‚Ä¢ Branch hasn't been created yet"
    echo "  ‚Ä¢ You don't have access to this branch"
    echo ""
    echo "üí° Suggestions:"
    echo "  1. Review current branch instead: ./$(basename "$0")"
    echo "  2. Check spelling and try again"
    echo "  3. List all local branches: git branch"
    echo "  4. Search remote branches: git ls-remote --heads origin | grep '<pattern>'"
    echo ""
    exit 1
}

# Function to normalize and validate branch name
normalize_branch_name() {
    local input_branch="$1"

    # If empty, return empty (will use current branch)
    if [ -z "$input_branch" ]; then
        echo ""
        return
    fi

    # Branch name is already provided, just validate it exists
    if [ "$REVIEW_TYPE" = "remote" ]; then
        # For remote, check if origin/branch exists
        if git rev-parse --verify "origin/$input_branch" >/dev/null 2>&1; then
            echo "$input_branch"
            return
        fi
    else
        # For local, check if branch exists
        if git rev-parse --verify "$input_branch" >/dev/null 2>&1; then
            echo "$input_branch"
            return
        fi

        # Try to find branch by pattern (e.g., if user provides just ticket ID)
        local found_branch=$(git branch --list "*$input_branch*" | head -n 1 | sed 's/^[* ]*//')
        if [ -n "$found_branch" ]; then
            print_status "Found matching branch: $found_branch"
            echo "$found_branch"
            return
        fi
    fi

    # If we get here, just return the input as-is (might be a new remote branch)
    echo "$input_branch"
}

# Function to get current branch name
get_current_branch() {
    if [ -z "$BRANCH_NAME" ]; then
        BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
        print_status "Using current branch: $BRANCH_NAME"
        REVIEWING_CURRENT_BRANCH=true
    else
        REVIEWING_CURRENT_BRANCH=false
        # Normalize the branch name
        local normalized=$(normalize_branch_name "$BRANCH_NAME")
        if [ -n "$normalized" ]; then
            BRANCH_NAME="$normalized"
        fi
        print_status "Using specified branch: $BRANCH_NAME"
    fi
}

# Function to create review context directory
create_review_context() {
    local jira_dir=""

    # Find jira directory
    if [[ "$REPO_ROOT" =~ /jira$ ]]; then
        jira_dir="$REPO_ROOT"
    elif [[ "$CURRENT_DIR" =~ /jira/ ]]; then
        jira_dir=$(echo "$CURRENT_DIR" | sed 's|/jira/.*|/jira|')
    else
        # Try to find jira directory in the repo
        jira_dir="$REPO_ROOT/jira"
        if [ ! -d "$jira_dir" ]; then
            print_warning "Could not locate jira directory, using repo root for context"
            jira_dir="$REPO_ROOT"
        fi
    fi

    CONTEXT_DIR="$jira_dir/.ai-cache/review/$BRANCH_NAME"
    mkdir -p "$CONTEXT_DIR"
}

# Function to perform local changes review
review_local_changes() {
    print_status "Performing local changes review..."

    local branch_ref="$BRANCH_NAME"
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local review_file="$CONTEXT_DIR/review.md"
    local current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

    print_status "Generating comprehensive review file..."

    # Determine base branch
    local base_branch="origin/master"
    if ! git rev-parse --verify "$base_branch" >/dev/null 2>&1; then
        base_branch="master"
    fi

    # Get commits that are ONLY in this branch (not in base)
    local unique_commits=$(git --no-pager log --oneline --no-merges "$branch_ref" --not "$base_branch" 2>/dev/null)
    local commit_count=$(echo "$unique_commits" | grep -c . || echo "0")

    # Get the merge base to compare changes properly
    local merge_base=$(git merge-base "$base_branch" "$branch_ref" 2>/dev/null || echo "$base_branch")

    # Get statistics for changes unique to this branch
    local files_changed=$(git --no-pager diff --name-only "$merge_base"..."$branch_ref" 2>/dev/null | wc -l | tr -d ' ')
    local insertions=$(git --no-pager diff --shortstat "$merge_base"..."$branch_ref" 2>/dev/null | grep -oE '[0-9]+ insertion' | grep -oE '[0-9]+' || echo "0")
    local deletions=$(git --no-pager diff --shortstat "$merge_base"..."$branch_ref" 2>/dev/null | grep -oE '[0-9]+ deletion' | grep -oE '[0-9]+' || echo "0")

    # SAFETY NET: Validate diff statistics before proceeding
    validate_diff_stats "$files_changed" "$insertions" "$deletions" "$branch_ref" "$merge_base...$branch_ref"

    # Start the review file
    cat > "$review_file" << EOF
# Code Review: $BRANCH_NAME

**Review Type:** Local Branch
**Base Branch:** $base_branch
**Target Branch:** $branch_ref
**Current Branch:** $current_branch
**Merge Base:** $merge_base
**Review Started:** $timestamp
**Repository:** $REPO_ROOT

## Summary

- **Unique Commits:** $commit_count (commits only in this branch)
- **Files Changed:** $files_changed
- **Insertions:** +$insertions lines
- **Deletions:** -$deletions lines

---

## Commits (unique to this branch)

EOF

    # Add only commits unique to this branch
    if [ -n "$unique_commits" ]; then
        echo "$unique_commits" >> "$review_file"
    else
        echo "No unique commits found (branch may be up to date with $base_branch)." >> "$review_file"
    fi

    # Add changed files summary
    cat >> "$review_file" << EOF

---

## Changed Files

EOF

    git --no-pager diff --name-status "$merge_base"..."$branch_ref" 2>/dev/null | while IFS=$'\t' read -r change_type file_path rest; do
        if [ -n "$change_type" ] && [ -n "$file_path" ]; then
            case "$change_type" in
                "A") echo "- **Added:** \`$file_path\`" ;;
                "M") echo "- **Modified:** \`$file_path\`" ;;
                "D") echo "- **Deleted:** \`$file_path\`" ;;
                "R"*) echo "- **Renamed:** \`$file_path\`" ;;
                "C"*) echo "- **Copied:** \`$file_path\`" ;;
                *) echo "- **Changed:** \`$file_path\`" ;;
            esac
        fi
    done >> "$review_file"

    # Add working tree status if reviewing current branch
    # When REVIEWING_CURRENT_BRANCH is true, we're always on the current branch
    if [ "$REVIEWING_CURRENT_BRANCH" = true ]; then
        cat >> "$review_file" << EOF

---

## Working Tree Status

\`\`\`
EOF
        git --no-pager status --short >> "$review_file" 2>/dev/null || echo "Clean working tree" >> "$review_file"
        echo '```' >> "$review_file"
    fi

    # Add statistics
    cat >> "$review_file" << EOF

---

## Change Statistics

\`\`\`
EOF

    git --no-pager diff --stat "$merge_base"..."$branch_ref" >> "$review_file" 2>/dev/null

    # Show staged and unstaged changes when reviewing current branch
    if [ "$REVIEWING_CURRENT_BRANCH" = true ]; then
        # Count files for quick context
        local staged_count=$(git diff --cached --name-only 2>/dev/null | wc -l | tr -d ' ')
        local unstaged_count=$(git diff --name-only 2>/dev/null | wc -l | tr -d ' ')

        echo "" >> "$review_file"
        echo "Staged changes ($staged_count files):" >> "$review_file"
        git --no-pager diff --cached --stat >> "$review_file" 2>/dev/null || echo "(no staged changes)" >> "$review_file"
        echo "" >> "$review_file"
        echo "Unstaged changes ($unstaged_count files):" >> "$review_file"
        git --no-pager diff --stat >> "$review_file" 2>/dev/null || echo "(no unstaged changes)" >> "$review_file"
    fi

    cat >> "$review_file" << EOF
\`\`\`

---

## Full Diff

\`\`\`diff
EOF

    # Add full diff
    git --no-pager diff "$merge_base"..."$branch_ref" >> "$review_file" 2>/dev/null || {
        echo "No changes found." >> "$review_file"
    }

    echo '```' >> "$review_file"

    # Show staged and unstaged changes when reviewing current branch
    # Progressive disclosure: committed ‚Üí staged ‚Üí unstaged
    if [ "$REVIEWING_CURRENT_BRANCH" = true ]; then
        # Count files for section headers
        local staged_file_count=$(git diff --cached --name-only 2>/dev/null | wc -l | tr -d ' ')
        local unstaged_file_count=$(git diff --name-only 2>/dev/null | wc -l | tr -d ' ')

        # Show staged changes first (committed ‚Üí staged ‚Üí unstaged order)
        if ! git diff --cached --quiet 2>/dev/null; then
            cat >> "$review_file" << EOF

---

## Staged Changes (Not Yet Committed) - $staged_file_count files

\`\`\`diff
EOF
            git --no-pager diff --cached >> "$review_file" 2>/dev/null
            echo '```' >> "$review_file"
        fi

        # Then show unstaged changes
        cat >> "$review_file" << EOF

---

## Unstaged Changes (Working Tree) - $unstaged_file_count files

\`\`\`diff
EOF
        git --no-pager diff >> "$review_file" 2>/dev/null || echo "No unstaged changes." >> "$review_file"
        echo '```' >> "$review_file"
    fi

    print_success "Review file created: $review_file"
}

# Function to perform remote branch review
review_remote_branch() {
    print_status "Performing remote branch review..."

    if [ -z "$BRANCH_NAME" ]; then
        print_error "Branch name required for remote review"
        exit 1
    fi

    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local review_file="$CONTEXT_DIR/review.md"

    print_status "Generating comprehensive review file..."

    # Extract ticket ID from branch name (e.g., JPO-35050 from JPO-35050-foster-ai-cleanup)
    local ticket_id=$(echo "$BRANCH_NAME" | grep -oE '[A-Z]+-[0-9]+' | head -1)

    # Get commits that are ONLY on this branch (not in master)
    # Using --no-merges to exclude merge commits entirely
    local relevant_commits=$(git --no-pager log --oneline --no-merges origin/"$BRANCH_NAME" --not origin/master 2>/dev/null)

    # If we have a ticket ID, filter to only commits mentioning it
    if [ -n "$ticket_id" ] && [ -n "$relevant_commits" ]; then
        local ticket_commits=$(echo "$relevant_commits" | grep -i "$ticket_id" || echo "")
        # Only use ticket-filtered commits if we found any
        if [ -n "$ticket_commits" ]; then
            relevant_commits="$ticket_commits"
        fi
    fi

    local commit_count=$(echo "$relevant_commits" | grep -c . || echo "0")

    # Use three-dot syntax to compare against merge-base
    # This shows only changes made on the branch, excluding merged content from master
    local merge_base=$(git merge-base origin/master origin/"$BRANCH_NAME" 2>/dev/null || echo "origin/master")
    commit_range="${merge_base}...origin/$BRANCH_NAME"

    # Get statistics for the relevant changes (only changes on this branch)
    local files_changed=$(git --no-pager diff --name-only $commit_range 2>/dev/null | wc -l | tr -d ' ')
    local insertions=$(git --no-pager diff --shortstat $commit_range 2>/dev/null | grep -oE '[0-9]+ insertion' | grep -oE '[0-9]+' || echo "0")
    local deletions=$(git --no-pager diff --shortstat $commit_range 2>/dev/null | grep -oE '[0-9]+ deletion' | grep -oE '[0-9]+' || echo "0")

    # SAFETY NET: Validate diff statistics before proceeding
    validate_diff_stats "$files_changed" "$insertions" "$deletions" "origin/$BRANCH_NAME" "$commit_range"

    # Start the review file
    cat > "$review_file" << EOF
# Code Review: $BRANCH_NAME

**Review Type:** Remote Branch
**Base Branch:** origin/master
**Target Branch:** origin/$BRANCH_NAME
**Ticket ID:** ${ticket_id:-"Not detected"}
**Commit Range:** $commit_range
**Review Started:** $timestamp
**Repository:** $REPO_ROOT

## Summary

- **Relevant Commits:** $commit_count
- **Files Changed:** $files_changed
- **Insertions:** +$insertions lines
- **Deletions:** -$deletions lines

---

## Commits

EOF

    # Add relevant commits
    if [ -n "$relevant_commits" ]; then
        echo "$relevant_commits" >> "$review_file"
    else
        echo "No commits found for review." >> "$review_file"
    fi

    # Add changed files summary
    cat >> "$review_file" << EOF

---

## Changed Files

EOF

    git --no-pager diff --name-status $commit_range 2>/dev/null | while IFS=$'\t' read -r change_type file_path rest; do
        if [ -n "$change_type" ] && [ -n "$file_path" ]; then
            case "$change_type" in
                "A") echo "- **Added:** \`$file_path\`" ;;
                "M") echo "- **Modified:** \`$file_path\`" ;;
                "D") echo "- **Deleted:** \`$file_path\`" ;;
                "R"*) echo "- **Renamed:** \`$file_path\`" ;;
                "C"*) echo "- **Copied:** \`$file_path\`" ;;
                *) echo "- **Changed:** \`$file_path\`" ;;
            esac
        fi
    done >> "$review_file"

    # Add statistics
    cat >> "$review_file" << EOF

---

## Change Statistics

\`\`\`
EOF

    git --no-pager diff --stat $commit_range >> "$review_file" 2>/dev/null

    cat >> "$review_file" << EOF
\`\`\`

---

## Full Diff

\`\`\`diff
EOF

    # Add full diff
    git --no-pager diff $commit_range >> "$review_file" 2>/dev/null || {
        echo "No changes found." >> "$review_file"
    }

    echo '```' >> "$review_file"

    print_success "Review file created: $review_file"
}


# Function to display summary
display_summary() {
    print_status "Review preparation complete!"
    echo ""
    echo "üìã Summary:"
    echo "  ‚Ä¢ Branch: $BRANCH_NAME"
    echo "  ‚Ä¢ Review Type: $REVIEW_TYPE"
    echo "  ‚Ä¢ Repository: $REPO_ROOT"
    echo ""
    echo "üìÑ Review File:"
    echo "  ‚Ä¢ $1/review.md"
    echo ""
    echo "This file contains:"
    echo "  - Branch information and metadata"
    echo "  - Complete commit history"
    echo "  - List of all changed files"
    echo "  - Change statistics"
    echo "  - Full diff of all changes"
    echo ""
    echo "üöÄ Next Steps:"
    echo "  1. Read the review.md file to see all changes"
    echo "  2. Provide code review feedback based on the changes"
    echo ""
    echo "üí° Tip: All git information is in one file for easy LLM consumption!"
}

# Function to cleanup temporary files
cleanup() {
    # Only cleanup if explicitly requested or on error
    if [ "$1" = "force" ] || [ "$2" = "error" ]; then
        print_status "Cleaning up review context..."
        if [ -n "$CONTEXT_DIR" ] && [ -d "$CONTEXT_DIR" ]; then
            rm -rf "$CONTEXT_DIR"
            print_success "Cleanup complete"
        fi
    fi
}

# Main execution
main() {
    print_status "Starting code review preparation..."
    print_status "Branch: ${BRANCH_NAME:-"current branch"}"
    print_status "Review Type: $REVIEW_TYPE"
    echo ""

    # Get repository information
    get_repo_info

    # Validate context
    validate_jira_context

    # Fetch latest master to ensure accurate merge-base calculation
    # This only updates origin/master reference, does not touch local branches
    print_status "Fetching latest master from origin..."
    if git fetch origin master >/dev/null 2>&1; then
        print_success "Successfully updated origin/master reference"
    else
        print_warning "Failed to fetch origin/master, using cached reference"
        print_warning "Review may include stale comparisons if master is outdated"
    fi

    # Validate branch exists BEFORE doing any work
    validate_branch_exists "$BRANCH_NAME"

    # Get branch name if not provided
    get_current_branch

    # Fetch remote branch if needed (only after validation)
    fetch_remote_branch

    # Create review context directory BEFORE performing review
    # This sets CONTEXT_DIR which is needed by review functions
    create_review_context
    print_success "Review context directory: $CONTEXT_DIR"

    # Perform review based on type
    if [ "$REVIEW_TYPE" = "remote" ]; then
        review_remote_branch
    else
        review_local_changes
    fi

    # Display summary
    display_summary "$CONTEXT_DIR"

    print_success "Code review preparation complete!"
    print_status "You can now run your code review command without permission prompts"
}

# Trap to cleanup on error only
trap 'cleanup force error' ERR

# Run main function
main "$@"
