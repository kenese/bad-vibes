<!-- meta:
  mode: expert
  topic: Accessibility issues and considerations
  audience: ai-agent
  model: sonnet-4
  token_budget: medium
  priority: high
  read_when: Fixing A11Y issues or making sure new code is compliant
  depends_on: [common.md, unit-testing.md, feature-gates-experiments.md]
  last_review: 2025-09-23
-->

<Accessibility-Work-Instructions>

Strictly follow the rules and instructions in this file and dependencies in the meta section.

<Rules>
- Every fix should be behind a feature gate
- Do not try to run the application
- Only modify needed files
- Understand the problem before adding a fix, if details are missing, ask user to provide them first.
- If there already is a fix for the same issue, ignore the task and do nothing.
- After adding the fix, make sure related unit tests pass.
- If adding props like `aria-*` never spread them.
- If more than one work item or ticket is given, try to group them and use the same feature gate for the fixes.
- If the user has provided a ticket or work item which contains a feature gate name, use that instead.
- If no feature gate name is given, come up with a meaningful name in the format of `feature-name-subfeature-a11y-fix`.
- Do not ask for user confirmation unless you lack enough details to get the task done.

</Rules>

<Required-Steps>

<File-Discovery>

Before making ANY changes, identify all files that need modification:

- Main files are usually called `index.tsx`, `view.tsx` or `view-old.tsx`, however, only work on
  `view-old.tsx` if the feature gate branch covers that.
- Story book examples are called `examples.tsx`
- Unit tests are called `test.tsx`, or `*.test.tsx`
- VR tests are usually put in `index.vr.tsx` inside `vr-tests` directory.

</File-Discovery>

<Implementation-Order>

- Update the main file first to fix the given issue
- Update the `examples.tsx` file if there is a case which will be covered by the feature gate
  condition and changes you made
- Update the unit tests only when the gate is being used, if there is no accessibility test, create
  a new unit tests and write one. DO NOT add any other tests, only A11Y related.
- Run the unit tests if possible using:

```zsh
# run this command from the root of jira folder
afm test /<test file path>/test.tsx
```

</Implementation-Order>

<General-Instructions>

- All work will take place inside `jira` directory, do not modify any files outside.
- Check all instances of the element in the file to make changes. If the same instance of the
  element is present in the file under condition, then apply changes in all instances.
- Do not remove any blank lines in any file.
- Do not nest ternary operators in the code.

  ```
  platform/packages/design-system/<component-name>/constellation/
  ├── index/               # Main component documentation
  │   ├── usage.mdx       # Usage guidelines and best practices
  │   ├── examples.mdx    # Implementation examples
  │   └── props.mdx       # API documentation
  ├── <variant-name>/     # Documentation for component variants
  │   ├── usage.mdx       # Variant-specific usage guidelines
  │   ├── examples.mdx    # Variant-specific examples
  │   └── code.mdx        # Variant-specific API docs
  ```

</General-Instructions>

<Feature-Gate-Instructions>

- Ensure all changes are behind a feature gate
- Import the feature gate if not already done:

```tsx
import { fg } from '@atlassian/jira-feature-gating';
```

- Importing of `fg` should be placed after any imports from `@atlaskit`.
- The `fg` method takes the feature gate as a string and returns true if the feature is on and false
- Never assign `fg` to any variable.

```tsx
if (fg('<feature_gate_name>')) {
		// code
}

// or in JSX
{fg('<feature_gate_name>') && <MyComponent />}

// or as a prop
<Component {...fg('<feature_gate_name>') ? { 'aria-label': '' } : {}} />

// as prop for boolean
<Component blurOnSelection={fg('<feature_gate_name>')} />

// with other conditions
<Commponent {...(hasError && fg('<feature-gate-name>')) ? { descriptionId: `${id}-error` } : {}} />
{hasError && <ErrorMessage {...(fg('<feature-gate-name>>') ? { id: `${id}-error`,  } : {})}>{errorMessage}</ErrorMessage>}
```

</Feature-Gate-Instructions>

<Storybook-Examples>

- If there is a story book example file `examples.tsx` make sure to update the examples to use the
  new feature gate:

```tsx
import { passGate } from '@atlassian/jira-feature-gates-storybook-mocks/src/index.tsx';

export const ExampleStory = () => {
	passGate('<feature_gate_name>');
	return <YourComponent />;
};
```

</Storybook-Examples>

<Unit-Testing>

- Update the unit test file `test.tsx` or `*.test.tsx`, but only the accessability section. You need
  to use the `passGate` to make sure new changes are applied to unit test if the code branch is
  covered by default.
- DO NOT add the `passGate` if the branch is not covered by default i.e. after interaction like
  click.
- If the unit test doesn't have A11Y check, add it.

✅ DO

```tsx
import { passGate } from '@atlassian/jira-feature-gates-storybook-mocks/src/index.tsx';

it('should capture and report a11y violations', async () => {
	passGate('<feature-gate-name>');
	const { container } = renderWithDi(<Component {...defaultProps} />);

	await expect(container).toBeAccessible();
});
```

- Run the unit test after to make sure it passes (make sure to use the relative file path from
  `jira` directory). The command also should be run from the root of `jira` folder.

```shell
afm test /test/file/path/test.tsx
```

</Unit-Testing>

<Final-CheckList>

Before completing any task, verify that you have:

- [] Found and analyzed ALL related files using tools such as grep_file_paths.
- [] Updated `examples.tsx` if it exists (REQUIRED for feature gates).
- [] Added feature gate imports in correct order (after `@atlaskit`).
- [] Applied feature gates correctly using recommended patterns.
- [] Added necessary tests for feature-gated behavior only if there are tests files available.
- [] Verified all changes maintain existing functionality.
- [] Verify all unit tests pass.

</Final-CheckList>

</Accessibility-Work-Instructions>
